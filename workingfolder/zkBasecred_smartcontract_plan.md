# Smart Contract Plan (Base, Groth16)

## Progress (as of 2026-02-05)

### Completed

- Scaffolded Foundry contracts package under `packages/contracts`.
- Added placeholder `Verifier.sol`.
- Implemented `DecisionRegistry.sol` with policy/context binding, replay protection, access control toggles, and decision binding.
- Added Foundry tests for success path, replay protection, policy hash mismatch, and invalid proof.
- Added Foundry deployment script and README quickstart notes.
- Added on-chain integration docs with ABI/event and example payload.
- Added circuit spec and a rule-encoded Circom circuit template for Groth16 generation.
- Completed range constraints and decision/context binding in circuit and contract.
- Added circuits tooling package with snarkjs scripts.
- Installed snarkjs and circomlib dependencies via `pnpm`.
- Installed circom and generated ptau, zkey, and real Groth16 verifier.
- Added Base deployment instructions to contracts README.
- Updated registry and docs to use fixed-size public signals and contextId mapping.
- Generated Groth16 verifier with public inputs (policyHash, contextId, decision).
- Deployed contracts to Base Sepolia and recorded addresses.
- Extracted contract ABIs and saved typed `.ts` modules under `packages/contracts/abi`.
- Documented ABI availability in the integration guide.
- Wired the on-chain contract metadata into the interface UI.
- Adjusted interface import to use the local ABI path.
- Added TS path alias so interface can import `@basecred/contracts/abi`.
- Declared `@basecred/contracts` as a workspace dependency for the interface.
- Added encoding module in decision-engine (`src/encoding/`) with:
  - Context ID encoding/decoding (context.ts)
  - Decision value encoding/decoding (decision.ts)
  - Signal encoding for circuits (signals.ts)
  - Policy hash to field element conversion (policyHash.ts)
  - Proof format conversion snarkjs â†’ contract (proof.ts)
  - Subject hash encoding (subject.ts)
- Created on-chain submission repository in interface (`decisionRegistryRepository.ts`).
- Created submission use case in interface (`submit-decision-onchain.ts`).
- Created submit API endpoint in interface (`/api/v1/agent/submit`).
- Added encoding tests in decision-engine (`encoding.test.ts`).
- Added submit use case tests in interface (`submit.test.ts`).
- Integrated RainbowKit wallet connection on agent page (`Providers.tsx`, `wagmiConfig.ts`).
- Auto-fill subject field with connected wallet address.
- Removed unnecessary SDK-to-Engine adapter (types match directly).

### In Progress

- None.

### Pending

- Deploy to Base mainnet and publish addresses/ABI.
- Add on-chain docs to external/public documentation site (if separate from repo).
- Client-side submission option for dApps (alternative to relayer).

## Scope

- Verify Groth16 proofs on-chain.
- Store decisions and audit metadata without raw scores.
- Base network deployment.
- Contracts live inside this repo under `packages/contracts` (not a separate repo).

## Phase 1: Contract Design

1. Verifier Contract
   - Groth16 verifier generated by SnarkJS.
   - Isolated `Verifier.sol`.
2. Registry Contract
   - Stores decision records keyed by `subjectHash + context`.
   - `submitDecision(...)` verifies proof and writes decision metadata.
   - Emits `DecisionSubmitted` event.
3. Repository structure
   - `packages/contracts/contracts` (Solidity)
   - `packages/contracts/scripts` (deploy)
   - `packages/contracts/test` (unit/integration tests)
   - `packages/contracts/README.md` (usage + addresses)

## Phase 2: Data Model

- Storage
  - `subjectHash` (bytes32)
  - `context` (bytes32 or string)
  - `decision` (uint8 enum)
  - `policyHash` (bytes32)
  - `timestamp` (uint64)
- Events
  - `DecisionSubmitted(subjectHash, context, decision, policyHash, timestamp)`

## Phase 3: Proof Integration

1. Public signals include `policyHash`, `contextId`, and `decision`.
2. `Verifier.verifyProof(a, b, c, publicSignals)` validates the proof.
3. Revert with explicit reason on invalid proofs.
4. Ensure public signal binding:
   - `policyHash` in public signals must match `policyHash` param.
   - `contextId` in public signals must match the `context` param encoding.
   - `decision` in public signals must match the `decision` param.

## Phase 4: Access & Security

1. Access control options:
   - Open submissions (any valid proof accepted)
   - Restricted role (relayer/agent)
2. Replay protection:
   - Use `subjectHash + context + policyHash` as unique key.
3. Upgrade strategy:
   - Avoid upgradeability unless explicitly required.
4. Reentrancy and input validation:
   - Reject empty `subjectHash`, `policyHash`, or malformed context.
   - Use `nonReentrant` if any external calls are added later.

## Phase 5: Deployment (Base)

1. Deploy `Verifier.sol` to Base.
2. Deploy `DecisionRegistry.sol` referencing verifier.
3. Publish addresses + ABI in docs/config and `packages/contracts/README.md`.

## Phase 6: Off-Chain Wiring

1. Agent submits proofs + public signals + decision metadata.
2. Update docs with:
   - ABI + events
   - Example transaction payload

## Notes

- Context7 is required for contract implementation and ABI integration.
- On-chain storage must never include raw scores or profile data.
- Current codebase only supports off-chain verification; on-chain contracts are pending implementation.
